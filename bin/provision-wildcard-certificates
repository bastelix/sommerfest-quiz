#!/usr/bin/env php
<?php

declare(strict_types=1);

use App\Infrastructure\Database;
use App\Service\CertificateZoneRegistry;
use App\Support\EnvLoader;
use DateTimeImmutable;
use DateTimeInterface;
use DateTimeZone;

require __DIR__ . '/../vendor/autoload.php';

EnvLoader::loadAndSet(__DIR__ . '/../.env');

$acmeBinary = getenv('ACME_SH_BIN') ?: 'acme.sh';
$dnsProvider = getenv('ACME_WILDCARD_PROVIDER') ?: 'dns_hetzner';
$certificateDir = getenv('NGINX_WILDCARD_CERT_DIR') ?: '/etc/ssl/wildcards';
$acmeHome = getenv('ACME_SH_HOME') ?: null;
$reloadOnChange = getenv('ACME_RELOAD_ON_SUCCESS') !== '0';

$pdo = Database::connectFromEnv();
$registry = new CertificateZoneRegistry($pdo);
$registry->backfillActiveDomains($dnsProvider);
$zones = $registry->listWildcardEnabled();

if ($dnsProvider === '') {
    fwrite(STDERR, "ACME_WILDCARD_PROVIDER is required.\n");
    exit(1);
}

$certChanged = false;
$nginxPidFile = '/run/nginx/nginx.pid';
foreach ($zones as $zone) {
    $name = $zone['zone'];
    if ($name === '') {
        continue;
    }

    $targetDir = rtrim($certificateDir, '/') . '/' . $name;
    if (!is_dir($targetDir) && !mkdir($targetDir, 0775, true) && !is_dir($targetDir)) {
        fwrite(STDERR, "Unable to create certificate directory for {$name}.\n");
        continue;
    }

    $fullchain = $targetDir . '/fullchain.pem';
    $previousHash = is_file($fullchain) ? hash_file('sha256', $fullchain) : null;

    $now = new DateTimeImmutable();
    $lastIssuedAt = $zone['last_issued_at'] !== null ? new DateTimeImmutable($zone['last_issued_at']) : null;
    $nextRenewalAfter = $zone['next_renewal_after'] !== null
        ? new DateTimeImmutable($zone['next_renewal_after'])
        : $registry->calculateNextRenewalWindow($lastIssuedAt);
    $certificateExpiry = readCertificateExpiry($fullchain);
    $forcedRenewal = $zone['status'] !== CertificateZoneRegistry::STATUS_ISSUED;

    $daysRemaining = $certificateExpiry !== null ? $now->diff($certificateExpiry)->format('%r%a') : null;

    $renewalDue = $forcedRenewal || $registry->isRenewalEligible($lastIssuedAt, $now) || $certificateExpiry === null;
    if ($certificateExpiry !== null && (int) $daysRemaining <= CertificateZoneRegistry::RENEWAL_THRESHOLD_DAYS) {
        $renewalDue = true;
    }

    if ($renewalDue === false) {
        $windowDescription = $nextRenewalAfter?->format(DateTimeInterface::ATOM) ?? 'unscheduled';
        $expiryDescription = $certificateExpiry !== null
            ? sprintf(
                '%s days remaining (expires %s)',
                $daysRemaining,
                $certificateExpiry->format(DateTimeInterface::ATOM)
            )
            : 'no expiry metadata available';
        logMessage(
            sprintf(
                'Skipping %s: certificate fresh, next renewal after %s; %s.',
                $name,
                $windowDescription,
                $expiryDescription
            )
        );
        continue;
    }

    logMessage(sprintf('Renewing %s (%s).', $name, $forcedRenewal ? 'queued' : 'window reached'));
    $registry->markPending($name, null, $now);

    $issueCommand = [$acmeBinary, '--issue', '--dns', $dnsProvider, '-d', $name, '-d', '*.' . $name];
    if ($acmeHome !== null && $acmeHome !== '') {
        $issueCommand[] = '--home';
        $issueCommand[] = $acmeHome;
    }

    if (!runCommand($issueCommand)) {
        $registry->markError($name, 'Issue command failed');
        continue;
    }

    $installCommand = [
        $acmeBinary,
        '--install-cert',
        '-d',
        $name,
        '--fullchain-file',
        $fullchain,
        '--key-file',
        $targetDir . '/privkey.pem',
    ];

    if ($acmeHome !== null && $acmeHome !== '') {
        $installCommand[] = '--home';
        $installCommand[] = $acmeHome;
    }

    if (!runCommand($installCommand)) {
        $registry->markError($name, 'Install command failed');
        continue;
    }

    $registry->markIssued($name, $now);

    $currentHash = is_file($fullchain) ? hash_file('sha256', $fullchain) : null;
    if ($currentHash !== null && $currentHash !== $previousHash) {
        $certChanged = true;
    }
}

if ($certChanged && $reloadOnChange) {
    if (!is_file($nginxPidFile) || !is_readable($nginxPidFile)) {
        fwrite(STDERR, "Skipping nginx reload: PID file missing or unreadable at {$nginxPidFile}.\n");
    } elseif (!runCommand(['nginx', '-s', 'reload'])) {
        fwrite(STDERR, "nginx reload failed after certificate update.\n");
        exit(1);
    }
}

function runCommand(array $command): bool
{
    $process = proc_open($command, [1 => ['pipe', 'w'], 2 => ['pipe', 'w']], $pipes);
    if (!is_resource($process)) {
        return false;
    }

    $stdout = stream_get_contents($pipes[1]);
    $stderr = stream_get_contents($pipes[2]);
    foreach ($pipes as $pipe) {
        if (is_resource($pipe)) {
            fclose($pipe);
        }
    }

    $exitCode = proc_close($process);
    if ($stdout !== '') {
        echo $stdout;
    }
    if ($stderr !== '') {
        fwrite(STDERR, $stderr);
    }

    return $exitCode === 0;
}

function readCertificateExpiry(string $certificatePath): ?DateTimeImmutable
{
    if (!is_file($certificatePath) || !is_readable($certificatePath)) {
        return null;
    }

    $content = @file_get_contents($certificatePath);
    if ($content === false) {
        return null;
    }

    $certificate = @openssl_x509_parse($content);
    if (!is_array($certificate) || !array_key_exists('validTo_time_t', $certificate)) {
        return null;
    }

    return (new DateTimeImmutable('@' . $certificate['validTo_time_t']))
        ->setTimezone(new DateTimeZone(date_default_timezone_get()));
}

function logMessage(string $message): void
{
    $timestamp = (new DateTimeImmutable())->format(DateTimeInterface::ATOM);
    fwrite(STDOUT, sprintf('[%s] %s%s', $timestamp, $message, PHP_EOL));
}
